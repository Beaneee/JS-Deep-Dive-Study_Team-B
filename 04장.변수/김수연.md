## 4.1 변수란 무엇인가? 왜 필요한가?

> 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

- 값의 위치를 가리키는 상징적인 이름
- 여러 개의 값을 저장하려면 여러 개의 변수를 사용해야 함
    <aside>
    💡 배열이나 객체 같은 자료구조를 사용하면 관련 있는 여러 개의 값을 그룹화해서 하나의 값처럼 사용 가능
    
    </aside>

- **변수 이름**: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- **변수 값**: 변수에 저장된 값
- 변수 이름과 변수 값은 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리됨
- **할당**: 변수에 값을 저장하는 것
- 변수를 사용하려면 반드시 [선언](https://github.com/JavaScript-Deep-Dive-Study/JS-Deep-Dive-Study_Team-B/blob/main/04%EC%9E%A5.%EB%B3%80%EC%88%98/%EA%B9%80%EC%88%98%EC%97%B0.md#43-%EB%B3%80%EC%88%98-%EC%84%A0%EC%96%B8)이 필요

## 4.2 식별자

> 메모리 상에 존재하는 어떤 값을 구별해서 식별할 수 있는 고유한 이름

- 값이 아닌 메모리 주소를 기억하고 있음
- **변수, 함수, 클래스 등의 이름은 모두 식별자**
  - 실행 컨텍스트에 등록됨
- [네이밍 규칙](https://github.com/JavaScript-Deep-Dive-Study/JS-Deep-Dive-Study_Team-B/blob/main/04%EC%9E%A5.%EB%B3%80%EC%88%98/%EA%B9%80%EC%88%98%EC%97%B0.md#47-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99)을 준수해야 함
- 선언하지 않은 식별자에 접근하면 ReferenceError(참조에러) 발생
    <aside>
    💡 **ReferenceError(참조에러)**
    
    자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러
    
    </aside>

## 4.3 변수 선언

> 변수를 생성하는 것

- 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비
- `var`, `let`, `const` 키워드를 사용
  - 키워드: 자바스크립트 코드를 해석하고 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어
    | | var | let | const |
    | ----------------------- | ---------------- | ---------------- | ---------------- |
    | 선언 단계와 초기화 단계 | 동시에 진행 | 분리되어 진행 | 분리되어 진행 |
    | 스코프 | 함수 레벨 스코프 | 블록 레벨 스코프 | 블록 레벨 스코프 |
    | 재할당 | 가능 | 가능 | 불가능 |
- **변수 선언 과정**
  - **선언 단계**: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
  - **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화
- 런타임 이전 단계에서 먼저 실행됨 ⇒ [**변수 호이스팅**]([https://www.notion.so/04-6dd30f06886b460fab99e8accd4cd647?pvs=21](https://github.com/JavaScript-Deep-Dive-Study/JS-Deep-Dive-Study_Team-B/blob/main/04%EC%9E%A5.%EB%B3%80%EC%88%98/%EA%B9%80%EC%88%98%EC%97%B0.md#%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85))

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

<aside>
💡 모든 선언문은 **런타임 이전 단계**에서 먼저 실행

</aside>

### 변수 호이스팅

> 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

- 변수 선언 뿐 아니라 `var`, `let`, `const`, `function`, `class` 키워드를 사용해서 선언하는 모든 식별자(변수, 함수 클래스 등)은 호이스팅 됨

## 4.5 값의 할당

```jsx
var score; // 변수 선언
score = 80; // 값의 할당

var score = 80; // 변수 선언과 값의 할당
```

- 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도, 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행

<aside>
📌 **변수 선언**과 **값의 할당**의 실행 시점이 다름

- 변수 선언: **런타임 이전**에 먼저 실행 ⇒ 변수 호이스팅
- 값의 할당: **런타임**에 실행

```jsx
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 80
```

</aside>

## 4.6 값의 재할당

> 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것

- 상수: 단 한 번만 할당할 수 있는 변수

<aside>
💡 **가비지 콜렉터**

애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 어떤 식별자도 참조하지 않는 메모리 공간을 해제하는 기능 ⇒ 메모리 누수 방지

</aside>

## 4.7 식별자 네이밍 규칙

- 식별자는 특수 문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함 가능
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 함. 숫자로 시작하는 것은 허용하지 않음
- 예약어(프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어)는 식별자로 사용 불가

<aside>
💡 자바스크립트의 일반적인 네이밍 컨벤션

- 카멜 케이스: 변수나 함수 ex) `var firstName;`
- 파스칼 케이스: 생성자 함수, 클래스 ex) `var FirstName;`
</aside>

---

## ✨ 관련 예상 질문

- **var 키워드의 단점에 대해서 설명해주세요.**
  첫 번째로 변수의 중복 선언이 가능합니다. 두 번째로는 함수 레벨 스코프이기 때문에 함수 내부의 변수 외에는 모두 전역 변수가 되어버립니다. 세 번째로는 변수 호이스팅이 발생해서 선언 이전의 변수도 사용이 가능해집니다.
  따라서 앞의 세가지 이유로 인해 의도치 않게 값이 바뀔 가능성이 커져버리고 예측 불가능한 코드가 될 수 있습니다.
- **변수 호이스팅과 함수 호이스팅의 차이점에 대해 설명해주세요.**
  변수 호이스팅은 변수 선언이 해당 스코프의 최상단으로 올려진 것처럼 동작하는 현상을 말합니다. 함수 호이스팅은 함수 선언이 스코프의 최상단으로 올려진 것처럼 동작하는 현상을 의미합니다.
- **블록 레벨 스코프와 함수 레벨 스코프에 대해서 설명해주세요.**
  블록 레벨 스코프는 모든 코드 블록(`if`, `for`, `while`, `try`/`catch` 등)을 유효범위로 인정하는 스코프입니다. 함수 레벨 스코프란, 오로지 함수의 코드 블록(함수 몸체)만을 유효범위로 인정하는 스코프입니다.
- **const 키워드를 사용해 선언한 변수가 상수로 사용되는 경우와 변수로 사용되는 경우에 대해서 각각 설명해주세요.**
  const 키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없으므로 상수로 사용됩니다. 그러나 객체를 할당한 경우에 값을 변경할 수 있는 변수로 사용됩니다.
