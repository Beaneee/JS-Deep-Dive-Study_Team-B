## 13.1 스코프란?

> 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 **자신이 선언된 위치**에 의해 다른 코드가 식별자 자신을 참조할 수 있는 **유효 범위**가 결정.

- **식별자가 유효한 범위**를 말한다.
- 자바스크립트 엔진이 **식별자를 검색할 때 사용하는 규칙**
  - **식별자 결정**: 자바스크립트 엔진이 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조해야 할 지 결정
    <aside>
    💡 **렉시컬 환경**: 코드가 어지서 실행되며 주변에 어떤 코드가 있는지
    
    - **실행 컨텍스트:** 코드의 문맥은 렉시컬 환경으로 이루어진다.
        - 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.
    </aside>

- **네임 스페이스**이다.
  - 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다.
      <aside>
      💡 스코프 내에서 식별자는 유일해야 하지만, 다른 스코프에서는 같은 이름을 사용할 수 있다.
      
      - **네임 바인딩**: 하나의 값은 유일한 식별자에 연결되어야 한다.
      </aside>
      
      <aside>
      📌 `var` 키워드로 선언된 변수는 **같은 스코프 내에서 중복 선언이 허용**된다.
      
      하지만 `let` 이나 `const` 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.
      
      </aside>


---

## 13.2 스코프의 종류

변수 선언 위치에 의해 유효 범위인 스코프가 결정

### 13.2.1 전역과 전역 스코프

- **전역**: 코드의 가장 바깥 영역
  - 전역에서 선언된 변수는 **전역 스코프**를 갖는 전역 변수이다.
    ⇒ 어디서든지 참조 가능하다.

### 13.2.2 지역과 지역 스코프

- **지역**: 함수 몸체 내부
  - 지역에서 선언된 변수는 **지역 스코프**를 갖는 지역 변수이다.
    ⇒ 자신이 선언된 지역과 하위 지역(중첩 함수)에서만 참조 가능하다.
    - 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다.
    - 코드 블록이 아닌 **함수에 의해서만 지역 스코프가 생성**된다.

---

## 13.3 스코프 체인

- **함수의 중첩**: 함수 몸체 내부에서 함수가 정의된 것
- 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있음.
  ⇒ **스코프가 함수의 중첩에 의해 계층적 구조를 갖는다**
  - **중첩 함수**: 함수 몸체 내부에서 정의한 함수
    - 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다.
    - **외부 함수의 지역 스코프**를 **중첩 함수의 상위 스코프**라 함
  - **외부 함수**: 중첩 함수를 포함하는 함수
    <aside>
    📌 모든 스코프는 하나의 계층적 구조로 연결되며, **모든 지역 스코프의 최상위 스코프**는 **전역 스코프**다.
    
    </aside>

- **스코프 체인**: 스코프가 계층적으로 연결된 것
    <aside>
    💡 변수를 참조할 때 자바스크립트 엔진은 **스코프 체인**을 통해 **변수를 참조하는 코드의 스코프에서 시작**하여 **상위 스코프 방향으로 이동**하며 선언된 변수를 검색한다.
    
    ⇒ 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있다.
    
    </aside>
    
    - 스코프 체인은 물리적인 실체로 존재
    - 자바스크립트 엔진은 코드(전역 코드와 함수 코드)를 실행하기에 앞서, **렉시컬 환경**을 실제로 생성
        
        <aside>
        💡 **스코프 체인**은 실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것이다.
        
        **전역 렉시컬 환경**은 코드가 로드되면 곧바로 생성되고 **함수의 렉시컬 환경**은 함수가 호출되면 곧바로 생성된다.
        
        </aside>
        
        - **변수 선언**이 실행되면, **변수 식별자**가 이 자료구조(렉시컬 환경)에 **키**로 등록
        - **변수 할당**이 일어나면, 이 자료구조(렉시컬 환경)의 변수 식별자에 해당하는 **값**을 변경
        - **변수의 검색**도 이 자료구조(렉시컬 환경) 상에서 이루어짐

### 13.3.1 스코프 체인에 의한 변수 검색

자바스크립트 엔진은 **스코프 체인**을 따라 **변수를 참조하는 코드의 스코프**에서 시작해서 **상위 스코프** 방향으로 이동하며 선언된 변수를 검색

<aside>
📌 하위 스코프로 내려가면서 식별자를 검색 하는 일은 없다.

⇒ **상위 스코프에서 유효한 변수**는 하위 스코프에서 자유롭게 참조할 수 있지만, **하위 스코프에서 유효한 변수**를 상위 스코프에서 참조할 수 없다

</aside>

### 13.3.2 스코프 체인에 의한 함수 검색

<aside>
💡 **함수 선언문**으로 함수를 정의하면 **런타임 이전에 함수 객체가 먼저 생성**된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당

</aside>

- 함수도 식별자에 할당되기 때문에 스코프를 가짐

---

## 13.4 함수 레벨 스코프

- **블록 레벨 스코프**: **모든 코드 블록(`if`, `for`, `while`, `try`/`catch` 등)**을 지역 스코프로 인정
- **함수 레벨 스코프**: 오로지 **함수의 코드 블록(함수 몸체)**만을 지역 스코프로 인정
  EX) `var` 키워드로 선언된 변수
  ```jsx
  var x = 1;

  if (true) {
    // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.
    // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수 이다.
    // 따라서 x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
    // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
    var x = 10;
  }

  console.log(x); // 10
  ```

<aside>
💡 **`var` 키워드**로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하지만,
ES6에서 도입된 **`let`, `const` 키워드**는 블록 레벨 스코프를 지원한다.

</aside>

---

## 13.5 렉시컬 스코프

**상위 스코프**를 결정하는 방식은 2가지가 존재

- **동적 스코프**: **함수를 어디서 호출했는지**에 따라 함수의 상위 스코프를 결정
  - 함수가 호출되는 시점에 동적으로 상위 스코프를 결정
- **렉시컬 스코프(정적 스코프)**: **함수를 어디서 정의했는지**에 따라 함수의 상위 스코프를 결정
  - **함수 정의가 평가되는 시점**에(함수 정의가 실행될 때) 상위 스코프가 정적으로 결정
  - 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따름.
  - **클로저**와 깊은 관계가 있다.
    <aside>
    📌 **함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다!**
    즉, **함수의 상위 스코프**는 언제나 **자신이 정의된 스코프**다.
    
    </aside>
    
    <aside>
    📌 **함수 정의(함수 선언문 또는 함수 표현식)**가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다. 함수가 호출될 때마다, 함수의 상위 스코프를 참조할 필요가 있기 때문이다.
    
    </aside>


---

## 🚀 인상 깊은 점

- 자바스크립트는 렉시컬 스코프를 따르는 것을 이해하고 나서는, 함수 호이스팅이 당연하게 여겨지는 것 같다.

## 💡 새로 알게된 개념

- 함수 객체는 상위 스코프를 기억한다.

## ✨ 관련 예상 질문

- 렉시컬 환경에 대해서 설명해주세요.
- 클로저에 대해서 설명해주세요.
